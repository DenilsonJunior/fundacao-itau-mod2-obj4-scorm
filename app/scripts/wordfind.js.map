{"version":3,"sources":["wordfind.js"],"names":["letters","allOrientations","horizontal","checkOrientations","diagonalBack","findBestLocations","placeWord","fillPuzzle","words","options","j","len","puzzle","i","height","w","x","width","horizontalBack","push","length","verticalUp","word","locations","y","vertical","sel","orientations","orientation","calcOverlap","floor","Math","next","square","overlap","skipOrientations","pruneLocations","pruned","exports","window","wordfind","h","l","diagonal","diagonalUp","diagonalUpBack","maxOverlap","k","nextPossible","check","wordLength","preferOverlap","skipTo","fnGetSquare","validOrientations","newPuzzle","settings","attempts","opts","wordList","sort","a","b","fillBlanks","undefined","maxAttempts","this","randomLetter","random","solve","slice","found","notFound","print","row","puzzleString","console","log","call"],"mappings":"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","file":"wordfind.js","sourcesContent":["/**\r\n* Wordfind.js 0.0.1\r\n* (c) 2012 Bill, BunKat LLC.\r\n* Wordfind is freely distributable under the MIT license.\r\n* For all details and documentation:\r\n*     http://github.com/bunkat/wordfind\r\n*/\r\n\r\n(function () {\r\n\r\n  'use strict';\r\n\r\n  /**\r\n  * Generates a new word find (word search) puzzle provided a set of words.\r\n  * Can automatically determine the smallest puzzle size in which all words\r\n  * fit, or the puzzle size can be manually configured.  Will automatically\r\n  * increase puzzle size until a valid puzzle is found.\r\n  *\r\n  * WordFind has no dependencies.\r\n  */\r\n\r\n  /**\r\n  * Initializes the WordFind object.\r\n  *\r\n  * @api private\r\n  */\r\n  var WordFind = function () {\r\n\r\n    // Letters used to fill blank spots in the puzzle\r\n    var letters = 'abcdefghijklmnoprstuvwy';\r\n\r\n    /**\r\n    * Definitions for all the different orientations in which words can be\r\n    * placed within a puzzle. New orientation definitions can be added and they\r\n    * will be automatically available.\r\n    */\r\n\r\n    // The list of all the possible orientations\r\n    var allOrientations = ['horizontal','horizontalBack','vertical','verticalUp',\r\n                           'diagonal','diagonalUp','diagonalBack','diagonalUpBack'];\r\n\r\n    // The definition of the orientation, calculates the next square given a\r\n    // starting square (x,y) and distance (i) from that square.\r\n    var orientations = {\r\n      horizontal:     function(x,y,i) { return {x: x+i, y: y  }; },\r\n      horizontalBack: function(x,y,i) { return {x: x-i, y: y  }; },\r\n      vertical:       function(x,y,i) { return {x: x,   y: y+i}; },\r\n      verticalUp:     function(x,y,i) { return {x: x,   y: y-i}; },\r\n      diagonal:       function(x,y,i) { return {x: x+i, y: y+i}; },\r\n      diagonalBack:   function(x,y,i) { return {x: x-i, y: y+i}; },\r\n      diagonalUp:     function(x,y,i) { return {x: x+i, y: y-i}; },\r\n      diagonalUpBack: function(x,y,i) { return {x: x-i, y: y-i}; }\r\n    };\r\n\r\n    // Determines if an orientation is possible given the starting square (x,y),\r\n    // the height (h) and width (w) of the puzzle, and the length of the word (l).\r\n    // Returns true if the word will fit starting at the square provided using\r\n    // the specified orientation.\r\n    var checkOrientations = {\r\n      horizontal:     function(x,y,h,w,l) { return w >= x + l; },\r\n      horizontalBack: function(x,y,h,w,l) { return x + 1 >= l; },\r\n      vertical:       function(x,y,h,w,l) { return h >= y + l; },\r\n      verticalUp:     function(x,y,h,w,l) { return y + 1 >= l; },\r\n      diagonal:       function(x,y,h,w,l) { return (w >= x + l) && (h >= y + l); },\r\n      diagonalBack:   function(x,y,h,w,l) { return (x + 1 >= l) && (h >= y + l); },\r\n      diagonalUp:     function(x,y,h,w,l) { return (w >= x + l) && (y + 1 >= l); },\r\n      diagonalUpBack: function(x,y,h,w,l) { return (x + 1 >= l) && (y + 1 >= l); }\r\n    };\r\n\r\n    // Determines the next possible valid square given the square (x,y) was ]\r\n    // invalid and a word lenght of (l).  This greatly reduces the number of\r\n    // squares that must be checked. Returning {x: x+1, y: y} will always work\r\n    // but will not be optimal.\r\n    var skipOrientations = {\r\n      horizontal:     function(x,y,l) { return {x: 0,   y: y+1  }; },\r\n      horizontalBack: function(x,y,l) { return {x: l-1, y: y    }; },\r\n      vertical:       function(x,y,l) { return {x: 0,   y: y+100}; },\r\n      verticalUp:     function(x,y,l) { return {x: 0,   y: l-1  }; },\r\n      diagonal:       function(x,y,l) { return {x: 0,   y: y+1  }; },\r\n      diagonalBack:   function(x,y,l) { return {x: l-1, y: x>=l-1?y+1:y    }; },\r\n      diagonalUp:     function(x,y,l) { return {x: 0,   y: y<l-1?l-1:y+1  }; },\r\n      diagonalUpBack: function(x,y,l) { return {x: l-1, y: x>=l-1?y+1:y  }; }\r\n    };\r\n\r\n    /**\r\n    * Initializes the puzzle and places words in the puzzle one at a time.\r\n    *\r\n    * Returns either a valid puzzle with all of the words or null if a valid\r\n    * puzzle was not found.\r\n    *\r\n    * @param {[String]} words: The list of words to fit into the puzzle\r\n    * @param {[Options]} options: The options to use when filling the puzzle\r\n    */\r\n    var fillPuzzle = function (words, options) {\r\n\r\n      var puzzle = [], i, j, len;\r\n\r\n      // initialize the puzzle with blanks\r\n      for (i = 0; i < options.height; i++) {\r\n        puzzle.push([]);\r\n        for (j = 0; j < options.width; j++) {\r\n          puzzle[i].push('');\r\n        }\r\n      }\r\n\r\n      // add each word into the puzzle one at a time\r\n      for (i = 0, len = words.length; i < len; i++) {\r\n        if (!placeWordInPuzzle(puzzle, options, words[i])) {\r\n          // if a word didn't fit in the puzzle, give up\r\n          return null;\r\n        }\r\n      }\r\n\r\n      // return the puzzle\r\n      return puzzle;\r\n    };\r\n\r\n    /**\r\n    * Adds the specified word to the puzzle by finding all of the possible\r\n    * locations where the word will fit and then randomly selecting one. Options\r\n    * controls whether or not word overlap should be maximized.\r\n    *\r\n    * Returns true if the word was successfully placed, false otherwise.\r\n    *\r\n    * @param {[[String]]} puzzle: The current state of the puzzle\r\n    * @param {[Options]} options: The options to use when filling the puzzle\r\n    * @param {String} word: The word to fit into the puzzle.\r\n    */\r\n    var placeWordInPuzzle = function (puzzle, options, word) {\r\n\r\n      // find all of the best locations where this word would fit\r\n      var locations = findBestLocations(puzzle, options, word);\r\n\r\n      if (locations.length === 0) {\r\n        return false;\r\n      }\r\n\r\n      // select a location at random and place the word there\r\n      var sel = locations[Math.floor(Math.random() * locations.length)];\r\n      placeWord(puzzle, word, sel.x, sel.y, orientations[sel.orientation]);\r\n\r\n      return true;\r\n    };\r\n\r\n    /**\r\n    * Iterates through the puzzle and determines all of the locations where\r\n    * the word will fit. Options determines if overlap should be maximized or\r\n    * not.\r\n    *\r\n    * Returns a list of location objects which contain an x,y cooridinate\r\n    * indicating the start of the word, the orientation of the word, and the\r\n    * number of letters that overlapped with existing letter.\r\n    *\r\n    * @param {[[String]]} puzzle: The current state of the puzzle\r\n    * @param {[Options]} options: The options to use when filling the puzzle\r\n    * @param {String} word: The word to fit into the puzzle.\r\n    */\r\n    var findBestLocations = function (puzzle, options, word) {\r\n\r\n      var locations = [],\r\n          height = options.height,\r\n          width = options.width,\r\n          wordLength = word.length,\r\n          maxOverlap = 0; // we'll start looking at overlap = 0\r\n\r\n      // loop through all of the possible orientations at this position\r\n      for (var k = 0, len = options.orientations.length; k < len; k++) {\r\n        \r\n        var orientation = options.orientations[k],\r\n            check = checkOrientations[orientation],\r\n            next = orientations[orientation],\r\n            skipTo = skipOrientations[orientation],\r\n            x = 0, y = 0;\r\n\r\n        // loop through every position on the board\r\n        while( y < height ) {\r\n\r\n          // see if this orientation is even possible at this location\r\n          if (check(x, y, height, width, wordLength)) {\r\n\r\n            // determine if the word fits at the current position\r\n            var overlap = calcOverlap(word, puzzle, x, y, next);\r\n\r\n            // if the overlap was bigger than previous overlaps that we've seen\r\n            if (overlap >= maxOverlap || (!options.preferOverlap && overlap > -1)) {\r\n              maxOverlap = overlap;\r\n              locations.push({x: x, y: y, orientation: orientation, overlap: overlap});\r\n            }\r\n\r\n            x++;\r\n            if (x >= width) {\r\n              x = 0;\r\n              y++;\r\n            }\r\n          }\r\n          else {\r\n            // if current cell is invalid, then skip to the next cell where\r\n            // this orientation is possible. this greatly reduces the number\r\n            // of checks that we have to do overall\r\n            var nextPossible = skipTo(x,y,wordLength);\r\n            x = nextPossible.x;\r\n            y = nextPossible.y;\r\n          }\r\n\r\n        }\r\n      }\r\n\r\n      // finally prune down all of the possible locations we found by\r\n      // only using the ones with the maximum overlap that we calculated\r\n      return options.preferOverlap ?\r\n             pruneLocations(locations, maxOverlap) :\r\n             locations;\r\n    };\r\n\r\n    /**\r\n    * Determines whether or not a particular word fits in a particular\r\n    * orientation within the puzzle.\r\n    *\r\n    * Returns the number of letters overlapped with existing words if the word\r\n    * fits in the specified position, -1 if the word does not fit.\r\n    *\r\n    * @param {String} word: The word to fit into the puzzle.\r\n    * @param {[[String]]} puzzle: The current state of the puzzle\r\n    * @param {int} x: The x position to check\r\n    * @param {int} y: The y position to check\r\n    * @param {function} fnGetSquare: Function that returns the next square\r\n    */\r\n    var calcOverlap = function (word, puzzle, x, y, fnGetSquare) {\r\n      var overlap = 0;\r\n\r\n      // traverse the squares to determine if the word fits\r\n      for (var i = 0, len = word.length; i < len; i++) {\r\n\r\n        var next = fnGetSquare(x, y, i),\r\n            square = puzzle[next.y][next.x];\r\n        \r\n        // if the puzzle square already contains the letter we\r\n        // are looking for, then count it as an overlap square\r\n        if (square === word[i]) {\r\n          overlap++;\r\n        }\r\n        // if it contains a different letter, than our word doesn't fit\r\n        // here, return -1\r\n        else if (square !== '' ) {\r\n          return -1;\r\n        }\r\n      }\r\n\r\n      // if the entire word is overlapping, skip it to ensure words aren't\r\n      // hidden in other words\r\n      return overlap;\r\n    };\r\n\r\n    /**\r\n    * If overlap maximization was indicated, this function is used to prune the\r\n    * list of valid locations down to the ones that contain the maximum overlap\r\n    * that was previously calculated.\r\n    *\r\n    * Returns the pruned set of locations.\r\n    *\r\n    * @param {[Location]} locations: The set of locations to prune\r\n    * @param {int} overlap: The required level of overlap\r\n    */\r\n    var pruneLocations = function (locations, overlap) {\r\n\r\n      var pruned = [];\r\n      for(var i = 0, len = locations.length; i < len; i++) {\r\n        if (locations[i].overlap >= overlap) {\r\n          pruned.push(locations[i]);\r\n        }\r\n      }\r\n\r\n      return pruned;\r\n    };\r\n\r\n    /**\r\n    * Places a word in the puzzle given a starting position and orientation.\r\n    *\r\n    * @param {[[String]]} puzzle: The current state of the puzzle\r\n    * @param {String} word: The word to fit into the puzzle.\r\n    * @param {int} x: The x position to check\r\n    * @param {int} y: The y position to check\r\n    * @param {function} fnGetSquare: Function that returns the next square\r\n    */\r\n    var placeWord = function (puzzle, word, x, y, fnGetSquare) {\r\n      for (var i = 0, len = word.length; i < len; i++) {\r\n        var next = fnGetSquare(x, y, i);\r\n        puzzle[next.y][next.x] = word[i];\r\n      }\r\n    };\r\n\r\n    return {\r\n\r\n      /**\r\n      * Returns the list of all of the possible orientations.\r\n      * @api public\r\n      */\r\n      validOrientations: allOrientations,\r\n\r\n      /**\r\n      * Returns the orientation functions for traversing words.\r\n      * @api public\r\n      */\r\n      orientations: orientations,\r\n\r\n      /**\r\n      * Generates a new word find (word search) puzzle.\r\n      *\r\n      * Settings:\r\n      *\r\n      * height: desired height of the puzzle, default: smallest possible\r\n      * width:  desired width of the puzzle, default: smallest possible\r\n      * orientations: list of orientations to use, default: all orientations\r\n      * fillBlanks: true to fill in the blanks, default: true\r\n      * maxAttempts: number of tries before increasing puzzle size, default:3\r\n      * preferOverlap: maximize word overlap or not, default: true\r\n      *\r\n      * Returns the puzzle that was created.\r\n      *\r\n      * @param {[String]} words: List of words to include in the puzzle\r\n      * @param {options} settings: The options to use for this puzzle\r\n      * @api public\r\n      */\r\n      newPuzzle: function(words, settings) {\r\n        var wordList, puzzle, attempts = 0, opts = settings || {};\r\n\r\n        // copy and sort the words by length, inserting words into the puzzle\r\n        // from longest to shortest works out the best\r\n        wordList = words.slice(0).sort( function (a,b) {\r\n          return (a.length < b.length) ? 1 : 0;\r\n        });\r\n        \r\n        // initialize the options\r\n        var options = {\r\n          height:       opts.height || wordList[0].length,\r\n          width:        opts.width || wordList[0].length,\r\n          orientations: opts.orientations || allOrientations,\r\n          fillBlanks:   opts.fillBlanks !== undefined ? opts.fillBlanks : true,\r\n          maxAttempts:  opts.maxAttempts || 3,\r\n          preferOverlap: opts.preferOverlap !== undefined ? opts.preferOverlap : true\r\n        };\r\n\r\n        // add the words to the puzzle\r\n        // since puzzles are random, attempt to create a valid one up to\r\n        // maxAttempts and then increase the puzzle size and try again\r\n        while (!puzzle) {\r\n          while (!puzzle && attempts++ < options.maxAttempts) {\r\n            puzzle = fillPuzzle(wordList, options);\r\n          }\r\n\r\n          if (!puzzle) {\r\n            options.height++;\r\n            options.width++;\r\n            attempts = 0;\r\n          }\r\n        }\r\n\r\n        // fill in empty spaces with random letters\r\n        if (options.fillBlanks) {\r\n          this.fillBlanks(puzzle, options);\r\n        }\r\n\r\n        return puzzle;\r\n      },\r\n\r\n      /**\r\n      * Fills in any empty spaces in the puzzle with random letters.\r\n      *\r\n      * @param {[[String]]} puzzle: The current state of the puzzle\r\n      * @api public\r\n      */\r\n      fillBlanks: function (puzzle) {\r\n        for (var i = 0, height = puzzle.length; i < height; i++) {\r\n          var row = puzzle[i];\r\n          for (var j = 0, width = row.length; j < width; j++) {\r\n\r\n            if (!puzzle[i][j]) {\r\n              var randomLetter = Math.floor(Math.random() * letters.length);\r\n              puzzle[i][j] = letters[randomLetter];\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n      * Returns the starting location and orientation of the specified words\r\n      * within the puzzle. Any words that are not found are returned in the\r\n      * notFound array.\r\n      *\r\n      * Returns\r\n      *   x position of start of word\r\n      *   y position of start of word\r\n      *   orientation of word\r\n      *   word\r\n      *   overlap (always equal to word.length)\r\n      *\r\n      * @param {[[String]]} puzzle: The current state of the puzzle\r\n      * @param {[String]} words: The list of words to find\r\n      * @api public\r\n      */\r\n      solve: function (puzzle, words) {\r\n        var options = {\r\n                        height:       puzzle.length,\r\n                        width:        puzzle[0].length,\r\n                        orientations: allOrientations,\r\n                        preferOverlap: true\r\n                      },\r\n            found = [],\r\n            notFound = [];\r\n\r\n        for(var i = 0, len = words.length; i < len; i++) {\r\n          var word = words[i],\r\n              locations = findBestLocations(puzzle, options, word);\r\n\r\n          if (locations.length > 0 && locations[0].overlap === word.length) {\r\n            locations[0].word = word;\r\n            found.push(locations[0]);\r\n          }\r\n          else {\r\n            notFound.push(word);\r\n          }\r\n        }\r\n\r\n        return { found: found, notFound: notFound };\r\n      },\r\n\r\n      /**\r\n      * Outputs a puzzle to the console, useful for debugging.\r\n      * Returns a formatted string representing the puzzle.\r\n      *\r\n      * @param {[[String]]} puzzle: The current state of the puzzle\r\n      * @api public\r\n      */\r\n      print: function (puzzle) {\r\n        var puzzleString = '';\r\n        for (var i = 0, height = puzzle.length; i < height; i++) {\r\n          var row = puzzle[i];\r\n          for (var j = 0, width = row.length; j < width; j++) {\r\n            puzzleString += (row[j] === '' ? ' ' : row[j]) + ' ';\r\n          }\r\n          puzzleString += '\\n';\r\n        }\r\n\r\n        console.log(puzzleString);\r\n        return puzzleString;\r\n      }\r\n    };\r\n  };\r\n\r\n  /**\r\n  * Allow library to be used within both the browser and node.js\r\n  */\r\n  var root = typeof exports !== \"undefined\" && exports !== null ? exports : window;\r\n  root.wordfind = WordFind();\r\n\r\n}).call(this);\r\n\r\n\r\n\r\n"]}